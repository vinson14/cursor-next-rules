---
description: This rule applies when making API calls to the backend, defining data fetching strategies, handling mutations, or configuring authentication in Next.js 16+.
alwaysApply: true
---

# API Calling Guidelines

## 1. Centralized Client (`@lib/apiClient`)

-   **Wrapper**: Use a lightweight wrapper around the native `fetch` API.
-   **Validation**: Use **Zod** schemas to parse and validate all API responses.
-   **Error Handling**: The client **must** throw an error if the response is not OK. It should never return `null` for errors.
-   **Error Schemas**: Optionally validate error responses (e.g., for Django validation errors) to ensure type safety when handling failures.

### Implementation

```typescript
import { z, ZodSchema } from "zod";

export class ApiError<E = any> extends Error {
    constructor(
        public status: number,
        public statusText: string,
        public data: E
    ) {
        super(`API Error ${status}: ${statusText}`);
        this.name = "ApiError";
    }
}

interface ApiClientOptions<E> extends RequestInit {
    revalidateSeconds?: number;
    errorSchema?: ZodSchema<E>;
}

export async function apiClient<T, E = any>(
    endpoint: string,
    schema: ZodSchema<T>,
    {
        cache = "no-store",
        revalidateSeconds,
        errorSchema,
        ...options
    }: ApiClientOptions<E> = {}
): Promise<T> {
    // Automatically handle auth on server
    const { accessToken } = await withAuth({ ensureSignedIn: true });

    const response = await fetch(endpoint, {
        cache,
        headers: {
            Authorization: `Bearer ${accessToken}`,
            ...options.headers,
        },
        next: revalidateSeconds ? { revalidate: revalidateSeconds } : undefined,
        ...options,
    });

    // 1. Handle HTTP Errors
    if (!response.ok) {
        const rawError = await response.json().catch(() => null);
        let errorData = rawError;

        // Optional: Parse structured error responses (e.g. Django DRF errors)
        if (errorSchema) {
            const parsed = errorSchema.safeParse(rawError);
            if (parsed.success) {
                errorData = parsed.data;
            }
        }

        throw new ApiError<E>(response.status, response.statusText, errorData);
    }

    const data = await response.json();

    // 2. Validate Response Shape (throws ZodError if invalid)
    return schema.parse(data);
}
```

## 2. Server Components

-   **Fetching**: Fetch data directly in Server Components using `async/await`.
-   **Error Handling**: Allow errors from `apiClient` to bubble up. Next.js `error.tsx` boundaries will catch them.
-   **404 Handling**: When the backend returns a 404 error, catch the `ApiError` and call Next.js's `notFound()` function. This will trigger the nearest `not-found.tsx` file to render.
-   **Caching**: Use `next: { tags: [...] }` for granular invalidation.

```typescript
import { notFound } from "next/navigation";
import { ApiError } from "@/lib/apiClient";

async function getProject(id: string) {
    try {
        return await apiClient(`/projects/${id}`, ProjectSchema, {
            next: { tags: ["projects"] },
        });
    } catch (error) {
        // Handle 404 errors by calling notFound()
        if (error instanceof ApiError && error.status === 404) {
            notFound();
        }
        // Re-throw other errors to be handled by error.tsx
        throw error;
    }
}
```

## 3. Mutations (Server Actions)

-   **Primary Method**: Perform all mutations (POST/PUT/DELETE) inside **Server Actions**.
-   **Error Handling**: Do **NOT** try/catch errors just to return `{ success: false }`. Let the error throw so the client (React Query) detects it as a failure.
-   **Revalidation**: Use `updateTag('tag-name')` for immediate consistency.

```typescript
"use server";
import { updateTag } from "next/cache";

// Define a common error schema for your backend (e.g. Django)
const DjangoErrorSchema = z.object({
    detail: z.string().optional(),
    code: z.string().optional(),
    // ... other standard DRF fields
});

export async function createProject(formData: FormData) {
    // 1. Validate Input
    const parsed = ProjectFormSchema.parse(Object.fromEntries(formData));

    // 2. Call API (Bubbles errors up)
    await apiClient("/projects", ProjectSchema, {
        method: "POST",
        body: JSON.stringify(parsed),
        errorSchema: DjangoErrorSchema, // Pass schema for typed error handling
    });

    // 3. Revalidate
    updateTag("projects");
}
```

## 4. Client Components

-   **Fetching**: Use **TanStack Query** (React Query) for data fetching in client components.
-   **Mutations**: Always wrap Server Actions in `useMutation` for client-side mutation handling. This provides proper error handling, loading states, and integration with React Query's cache.
-   **Forms**: See the [Forms Guidelines](./forms.mdc) for detailed form implementation with React Hook Form integration.

```typescript
"use client";

import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { createProjectAction, getProjectsAction } from "@/app/actions/projects";

export function ProjectsList() {
    const queryClient = useQueryClient();

    // Fetching: Use useQuery with Server Actions
    const { data, isLoading } = useQuery({
        queryKey: ["projects"],
        queryFn: getProjectsAction,
    });

    // Mutations: Always wrap Server Actions in useMutation
    const { mutate, isPending } = useMutation({
        mutationFn: createProjectAction,
        onSuccess: () => {
            // Invalidate queries to refetch
            queryClient.invalidateQueries({ queryKey: ["projects"] });
        },
        onError: (error) => {
            // Handle errors (see Forms rule for form-specific error handling)
            console.error("Failed to create project:", error);
        },
    });

    // ... component implementation
}
```

## 5. Error Handling Architecture

| Layer                    | Responsibility     | Action on Error                                                                                                                                  |
| :----------------------- | :----------------- | :----------------------------------------------------------------------------------------------------------------------------------------------- |
| **`apiClient`**          | Network & Protocol | **Throws** `ApiError` (HTTP status) or `ZodError` (Schema mismatch).                                                                             |
| **Server Action**        | Business Logic     | **Bubbles** error up. Does not catch.                                                                                                            |
| **Server Component**     | Page Rendering     | **Bubbles** error up to `error.tsx` boundary. **404 errors**: Catch `ApiError` with status 404 and call `notFound()` to trigger `not-found.tsx`. |
| **Client (React Query)** | UI Feedback        | **Catches** in `onError`. Maps to Form Errors or Toasts.                                                                                         |

## 6. Type Safety

-   **Single Source of Truth**: Define Zod schemas in `@types/*` or colocated with features.
-   Infer TypeScript types from Zod schemas:
    ```typescript
    export type Project = z.infer<typeof ProjectSchema>;
    ```
